<!DOCTYPE html>
<html lang="en">

<head>
  <title>ReMarkable Canvas</title>
  <meta charset="UTF-8">
  <style>
      #container {
          position: relative;
          border: 1px solid #aaa;
      }

      .normal {
          width: 1176px;
          height: 750px;
      }

      .rotated {
          height: 750px;
          width: 478px;
      }

      .border {
          border: 1px solid black;
      }
  </style>
</head>

<body>
  <div style="display: flex; flex-direction: row; flex-wrap: nowrap">
    <div>
      <label>Address: <input type="text" id="address"></label>
      <button onclick="connect()">Connect</button>
      <div>Status:
        <div id="status" style="display: inline">Not yet connected</div>
      </div>
    </div>
    <div style="display: block; margin-left: 20px">
      <div>
        <label>Change Pensize with Pressure:
          <input id="pressureCheckbox" type="checkbox" oninput="updatePressureResponse()" checked>
        </label>
      </div>
      <div>
        <label>Pen size:
          <input id="pensizeSelector" type="number" min="1" max="100" oninput="updateLineWidth()" value="16">
        </label>
      </div>
    </div>
  </div>
  <hr>
  <div id="container" class="normal">
    <canvas width="1176" height="750" style="position: absolute; left: 0;top: 0" class="border"
            id="canvas-overlay"></canvas>
    <canvas width="1176" height="750" style="position: absolute; left: 0;top: 0" class="border" id="canvas"></canvas>
  </div>
  <p>Enter to rotate canvas, Space to clear screen</p>
<!--  <br>-->
<!--  <p id="debug_pos"></p>-->

  <script>

    // Found by finding the maximum values when experimenting
    const MAX_X = 20966;
    const MAX_Y = 15725;
    const RATIO = MAX_X / MAX_Y;
    const MAX_PRESSURE = 4096;
    const MAX_DISPLAY_PRESSURE = 10;
    const NORMAL_HEIGHT = 750;
    const NORMAL_WIDTH = 1176;
    const ROTATED_HEIGHT = 750;
    const ROTATED_WIDTH = 478;

    let rotation = false;

    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");

    let canvasOverlay = document.getElementById("canvas-overlay");
    let ctxOverlay = canvasOverlay.getContext("2d");

    let lineWidthModifier = 2.0;
    let usePenPressure = true;

    let scalePressure = MAX_DISPLAY_PRESSURE / MAX_PRESSURE;

    let penState = false;

    let lastX = null;
    let lastY = null;

    function translateX(x, y) {
      if (rotation) {
        return y * ROTATED_WIDTH / MAX_Y;
      } else {
        return x * NORMAL_WIDTH / MAX_X;
      }
    }

    function translateY(x, y) {
      if (rotation) {
        return  ROTATED_HEIGHT - (x * ROTATED_HEIGHT / MAX_X);
      } else {
        return y * NORMAL_HEIGHT / MAX_Y;
      }
    }

    function updateLineWidth() {
      lineWidthModifier = document.getElementById("pensizeSelector").value / 8;
    }

    function updatePressureResponse() {
      usePenPressure = document.getElementById("pressureCheckbox").checked;
    }

    function calculateLineWidth(pressure) {
      console.log(pressure, MAX_PRESSURE, lineWidthModifier);
      if (usePenPressure) {
        let p = pressure / MAX_PRESSURE;
        return lineWidthModifier * (p - 0.5) * 2;
      } else {
        return lineWidthModifier;
      }
    }

    function connect() {
      let address = document.getElementById("address").value;

      document.getElementById("status").textContent = "connecting...";
      console.log("Attempting to connect to ws://" + address);
      let websocket;
      try {
        websocket = new WebSocket("ws://" + address);
      } catch (e) {
        document.getElementById("status").textContent = "Error";
      }

      websocket.onopen = function () {
        console.log("Connected");
        document.getElementById("status").textContent = "Connected";
      }

      websocket.onerror = function () {
        console.log("Error");
        document.getElementById("status").textContent = "Error";
      }

      websocket.onclose = function () {
        console.log("Disconnected");
        if (document.getElementById("status").textContent !== "Error") {
          document.getElementById("status").textContent = "Disconnected";
        }
      }

      websocket.onmessage = function (event) {
        // data is [x, y, pressure, mode]
        // mode 0 = erase
        // mode 1 = pen
        let data = JSON.parse(event.data);
        // console.log("x:", data[0], "y:", data[1], "p:", data[2],"t:",data[3]);

        let x = translateX(data[0], data[1]);
        let y = translateY(data[0], data[1]);
        let pressure = data[2];
        let mode = data[3];

        // document.getElementById("debug_pos").textContent = Math.floor(x) + " x " + Math.floor(y);

        overlay(x, y, pressure, mode);
        draw(x, y, pressure, mode);
        penState = pressure > 0;
      };
    }

    function draw(x, y, pressure, mode) {
      // Only start drawing if we already started a line.
      if (penState) {
        if (mode === 1) {
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = calculateLineWidth(pressure);
          ctx.globalCompositeOperation = "source-over";
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(x, y);
          ctx.stroke();
        } else if (mode === 0) {
          ctx.fillStyle = "#000000";
          ctx.globalCompositeOperation = "destination-out";
          ctx.beginPath();
          ctx.arc(x, y, 20, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      // Always assign last x and y when there's pen pressure,
      // to mark the start of a line.
      lastX = x;
      lastY = y;
    }

    function overlay(x, y, pressure, mode) {
      // Clear when hovering, but keep drawing for the duration of a stroke to highlight it.
      if (!penState) {
        ctxOverlay.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);
      }
      ctxOverlay.fillStyle = mode === 1 ? "rgb(200,200,255)" : "rgb(255,200,200)";
      ctxOverlay.beginPath();
      ctxOverlay.arc(x, y, 10, 0, 2 * Math.PI);
      ctxOverlay.fill();
    }

    document.addEventListener('keydown', function (e) {
      if (e.code === "Enter" || e.code === "KeyD") {
        // enter for rotated
        let container = document.getElementById("container");
        rotation = !rotation;
        console.log("Rot: ", rotation);

        if (rotation) {
          container.className = "rotated";
          canvas.width = ROTATED_WIDTH;
          canvas.height = ROTATED_HEIGHT;
          canvasOverlay.width = ROTATED_WIDTH;
          canvasOverlay.height = ROTATED_HEIGHT;
        } else {
          container.className = "normal";
          canvas.width = NORMAL_WIDTH;
          canvas.height = NORMAL_HEIGHT;
          canvasOverlay.width = NORMAL_WIDTH;
          canvasOverlay.height = NORMAL_HEIGHT;
        }
      } else if (e.code === "Space") {
        // Space for clear.
        e.preventDefault();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctxOverlay.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);
      }
    });

    document.getElementById("address").value = window.location.hostname + ":55555";
    connect();
  </script>
</body>

</html>
