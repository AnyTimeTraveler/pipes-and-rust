<!DOCTYPE html>
<html lang="en">

<head>
  <title>ReMarkable Canvas</title>
  <meta charset="UTF-8">
  <style>
      #container {
          position: relative;
          border: 1px solid #aaa;
      }

      .normal {
          width: 1176px;
          height: 750px;
      }

      .rotated {
          width: 750px;
          height: 1176px;
      }

      .border {
          border: 1px solid black;
      }
  </style>
</head>

<body>
  <div style="display: flex; flex-direction: row; flex-wrap: nowrap">
    <div>
      <label>Address: <input type="text" id="address"></label>
      <button onclick="connect()">Connect</button>
      <div>Status:
        <div id="status" style="display: inline">Not yet connected</div>
      </div>
    </div>
    <div style="display: block; margin-left: 20px">
      <div>
        <label>Change Pensize with Pressure:
          <input id="pressureCheckbox" type="checkbox" oninput="updatePressureResponse()" checked>
        </label>
      </div>
      <div>
        <label>Pen size:
          <input id="pensizeSelector" type="number" min="1" max="100" oninput="updateLineWidth()" value="16">
        </label>
      </div>
    </div>
  </div>
  <hr>
  <div id="container" class="normal">
    <canvas width="1176" height="750" style="position: absolute; left: 0;top: 0" class="border" id="canvas-overlay"></canvas>
    <canvas width="1176" height="750" style="position: absolute; left: 0;top: 0" class="border" id="canvas"></canvas>
  </div>
  <p>Enter to rotate canvas, Space to clear screen</p>

  <script>

    // Found by finding the maximum values when experimenting
    const MAX_X = 20966;
    const MAX_Y = 15725;
    const RATIO = MAX_X / MAX_Y;
    const MAX_PRESSURE = 4096;
    const MAX_DISPLAY_PRESSURE = 10;
    const RINGBUFFER_SIZE = 10;

    let rotation = 0;

    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");

    let canvasOverlay = document.getElementById("canvas-overlay");
    let ctxOverlay = canvasOverlay.getContext("2d");

    let lineWidthModifier = 2.0;
    let usePenPressure = true;

    let scaleX = canvas.width / MAX_X;
    let scaleY = canvas.height / MAX_Y;
    let scalePressure = MAX_DISPLAY_PRESSURE / MAX_PRESSURE;

    let penState = false;

    // Ring buffer to smooth out values.
    let ringbufferX = new Float64Array(RINGBUFFER_SIZE);
    let ringbufferY = new Float64Array(RINGBUFFER_SIZE);
    let ringbufferZ = new Float64Array(RINGBUFFER_SIZE);
    let mode = 0;

    let rbI = 0;

    let debug = false;

    let lastX = null;
    let lastY = null;

    function updateLineWidth() {
      lineWidthModifier = document.getElementById("pensizeSelector").value / 8;
    }

    function updatePressureResponse() {
      usePenPressure = document.getElementById("pressureCheckbox").checked;
    }

    function calculateLineWidth(pressure) {
      console.log(pressure, MAX_PRESSURE, lineWidthModifier);
      if (usePenPressure) {
        let p = pressure / MAX_PRESSURE;
        return lineWidthModifier * (p - 0.5) * 2;
      } else {
        return lineWidthModifier;
      }
    }

    function connect() {
      let address = document.getElementById("address").value;

      document.getElementById("status").textContent = "connecting...";
      console.log("Attempting to connect to ws://" + address);
      let websocket;
      try {
        websocket = new WebSocket("ws://" + address);
      } catch (e) {
        document.getElementById("status").textContent = "Error";
      }

      websocket.onopen = function () {
        console.log("Connected");
        document.getElementById("status").textContent = "Connected";
      }

      websocket.onerror = function () {
        console.log("Error");
        document.getElementById("status").textContent = "Error";
      }

      websocket.onclose = function () {
        console.log("Disconnected");
        if (document.getElementById("status").textContent !== "Error") {
          document.getElementById("status").textContent = "Disconnected";
        }
      }

      websocket.onmessage = function (event) {
        // data is [x, y, pressure, mode]
        let data = JSON.parse(event.data);

        // Pre-increment rbI so we can use it in draw to refer to the current head.
        rbI = (rbI + 1) % RINGBUFFER_SIZE;
        ringbufferX[rbI] = data[0];
        ringbufferY[rbI] = data[1];
        ringbufferZ[rbI] = data[2];
        mode = data[3];

        overlay(data[0] * scaleX, data[1] * scaleY);

        draw();

        if (debug) {
          ctx.fillStyle = "red";
          ctx.beginPath();
          ctx.fillRect(data[0] * scaleX, data[1] * scaleY, 2, 2);
          ctx.fill();
        }
      };
    }

    function draw() {
      // Loop through ringbuffer elements...
      // Average all ringbuffer elements where the pressure is nonzeroish.
      let avgX = 0;
      let avgY = 0;
      let avgZ = 0;
      let cnt = 0;
      for (let i = 0; i < RINGBUFFER_SIZE; i++) {
        // If this does look like the end of a stroke, still use the whole
        // framebuffer. It's short enough to drain quickly without confusing
        // this stroke with the next.
        if (ringbufferZ[i] > 10) {
          avgX += ringbufferX[i];
          avgY += ringbufferY[i];
          avgZ += ringbufferZ[i];
          cnt += 1;
        }
      }

      avgX /= cnt;
      avgY /= cnt;
      avgZ /= cnt;
      avgX *= scaleX;
      avgY *= scaleY;

      // If there were zero entries with nonzero pressure, that's the
      // end of a stroke. Forget the last point.
      if (cnt === 0) {
        penState = false;
        lastX = null;
        lastY = null;
      } else {
        // Only start drawing if we already started a line.
        if (penState) {
          if (mode === 0) {
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = calculateLineWidth(avgZ);
            ctx.globalCompositeOperation = "source-over";
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(avgX, avgY);
            ctx.stroke();
          } else {
            ctx.fillStyle = "#000000";
            ctx.globalCompositeOperation = "destination-out";
            ctx.beginPath();
            ctx.arc(avgX, avgY, 20, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
        penState = true;

        // Always assign last x and y when there's pen pressure,
        // to mark the start of a line.
        lastX = avgX;
        lastY = avgY;
      }
    }

    function overlay(x, y) {
      // Clear when hovering, but keep drawing for the duration of a stroke to highlight it.
      if (!penState) {
        ctxOverlay.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);
      }
      ctxOverlay.fillStyle = mode === 0 ? "rgb(200,200,255)" : "rgb(255,200,200)";
      ctxOverlay.beginPath();
      ctxOverlay.arc(x, y, 20, 0, 2 * Math.PI);
      ctxOverlay.fill();
    }

    document.addEventListener('keydown', function (e) {
      if (e.code === "Enter" || e.code === "KeyD") {
        // enter for rotated
        let container = document.getElementById("container");
        rotation += 90;
        rotation %= 360;
        console.log("Rot: ", rotation);
        if (rotation % 180 === 0) {
          container.className = "normal";
        } else {
          container.className = "rotated";
        }

        rotateCanvas(ctx, canvas);
        rotateCanvas(ctxOverlay, canvasOverlay);
      } else if (e.code === "Space") {
        // Space for clear.
        e.preventDefault();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctxOverlay.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);
      } else if (e.code === "KeyD") {
        // 'd' for debug
        debug = !debug;
      }
    });

    function degs_to_rads(degs) {
      return degs / (180 / Math.PI);
    }

    function rotateCanvas(ctx, canvas) {
      let oldWidth = canvas.width;
      // noinspection JSSuspiciousNameCombination
      canvas.width = canvas.height;
      // noinspection JSSuspiciousNameCombination
      canvas.height = oldWidth;

      ctx.setTransform(1, 0, 0, 1, 0, 0);

      let centerX = canvas.width / 2;
      let centerY = canvas.height / 2;

      ctx.translate(centerX, centerY);
      ctx.rotate(degs_to_rads(rotation));
      ctx.translate(-canvas.width, -canvas.height);
    }

    document.getElementById("address").value = window.location.hostname + ":55555";
    connect();
  </script>
</body>

</html>
